1) Within my program, there are two structs (Reaction and Chat) that need to be allocated, a list of the Chat objects, and a list of the ids of each chat. Within the Chat, there is a user, message, id, Reaction object, and reaction list. Each of these strings can grow depending on the user's inputs. In this case, if you max them out, the user and message take up 270 bytes total. Going into the React object, this contains a user and message string. These are both allocated depending on the user, so their size changes as well. As for the size, there would be a total of 30 bytes combined, however, they are not used since no one reacted to them. There are additional strings and pointers that are allocated, however, they are only used to point and search for objects and then freed.From here, the chat array stores a Chat object containing a Reaction object. This means that for one Chat object, it would be up to 270 bytes. So this means that for 10 chats there are 27000 bytes, 100 chats would be 27000 bytes, and 1000 chats would be 270000 bytes. When calling the /chats request in my program, there are Chat and Reaction pointers that point to each of the objects within the chat array and print them out. In this case, the /chat request would have a similar size as the working memory within my program. 

To lower the chat storage, or the memory use, to process a request, something that I could do is dynamically process each of the strings rather than setting up a max for each of them. In addition to this, there are other ways of storing strings such as third party storage (cloud) or converting them into txt files that may be stored somewhere and read off of to retrieve the information. Moreover, another way to adjust for this is to improve on the structure of the program. Rather than only using two different structs, you can allocate memory for each part of the program, making the entire program memory dynamic. This would allow you to free up each part and use less memory. 

2) The constraint that I would choose to remove are the messages. Something that would work now is the ability to send very long text messages without having the need to limit their text. In addition to this, the user is allowed to use multiple special characters within their text because the previous limits would restrict them to a specific amount of special characters or emojis. However, the downside to this is that the memory would take up a significant portion of the code, in addition, there would be issues possibly freeing up the information for other tasks. This would be a big issue because using dynamically allocated memory is not unlimited and there is an extent to where the memory can be allocated onto the heap. This would be a huge issue because of how the message section is a significant portion of the messaging app, and increasing size on this could cause a significant toll on the speed and efficiency of the program. Putting this into perspective, a user can use up to possibly hundreds of thousands of bytes writing an entire essay filled with special characters and emojis. This would be no issue for the program as it is able to allocate this memory onto the heap. However, the issue comes when there are people that want to react or want to respond to the person's message. Since the original message took up an arbitary number of bytes on the heap, there is limited space to utilize to allocate these strings and Chat/Reaction objects. As a result, the other users may possibly be limited in what they can say, or the chat would be significantly slower or encounter a segmentation error. Moreover, there could possibly issues with "garbage cleaning" as the free function may fragment the allocated data in ways that would limit the addition of more Chat/Reaction objects.


**RESUBMIT**
1. One good thing about this alternate design is that you can store the values for each chat without having to store memory for the struct. By adding all of the values to the string, you can store them in a 2d array that can store all the values that the program would need to run each part correctly. Moreover, if adjusting structs and accessing their values is an issue for the programmer, using a string can simplify the issue. On the other hand, an issue could possibly be if the user decides to have very long string and multiple reactions, there would be a large useage of memory. Another issue is that the programmer would have a hard time adjusting the components of each chat as they would have to continue to malloc and realloc the strings everytime the user makes a reaction or chat call. As a result of this, the program can slow down due to some freeing issues that the programmer may occur as a result of all of these malloc and freeing calls, or that the size of the heap would be used up due to the formatting of each string.

2. This char** design would make it harder to add the /edit feature due to the possible overflows from previous strings and allocation/freeing issues. Like I had mentioned previously, if you were to incorporate this design, the strings for each chat would keep growing over and over, as the programmer would have to implement multiple alloc and realloc calls that would fill up the heap. In addition to this, if the programmer were to implement /edit with this, they would have to free and realloc each string array just to make minor adjustments to a singular chat. Moreover, they would have to store and write over the previous reactions, and usernames which would be a struggle as it would take up a huge amount of memory. As for overflows, since there are multiple strings in the heap, the programmer could potentially forget to adjust the size of the strings and would result in an overwritting of the data from adjacent strings. In addition to this, the programmer would have to make sure to effectively keep track of all the arrays and make sure that they were being adjusted correctly. 
