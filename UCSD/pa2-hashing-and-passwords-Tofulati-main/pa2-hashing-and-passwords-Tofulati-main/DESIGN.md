1. Two methods that password crackers would use are: Credential stuffing and Spidering. These two methods are notorious in password cracking as it gets an inside look to how a user thinks and how they may potentially create their passwords. If I were to utilize credential stuffing, I would introduce a dictionary that has the user's known usernames and passwords and place them in various orders. In addition to this, I would test different kinds of uppercasing or lowercasing and place character values that could be substituted, such as o for 0. As for spidering, something that I would implement is similar to credential stuffing, in where I would create a dictionary from scrapping a user's social media or personal content. From this dictionary, I would try various placements of the words, uppercasing/lowercasing, and replacement of characters for similar characters (such as 0 for o or O).

2. There needs to be a total of n^3 working memory needed to store all of the variables needed to excecute the password cracker; n being the length of one of the inputs in the password cracker. This is because for each of the passwords that you are testing, they need to be inserted into an array storing each value. This would be n by n since each row of the array would store the possible passwords on top of each other, assuming each is length n. In addition to this, we would need to test multiple variations of the password. Since each password is n length, we would have to go through each of the variables and adjust them (in this case, upper/lowercase) and store those values as well. This would mean that we have a 3d array that would store all of the possible passwords to test. In addition to this, each of the possible passwords could be various lengths, which could mean that even more memory is taken up. This would greatly influence the memory space of the program as a majority of the program is developing variations of possible passwords and not really the comparison speed. Therefore, memory is more of an issue than the processing power of the code.

Resubmit:
1. There are a total of 34 password variations that are hashed and tested. This is because the characters "secret" can uppercase each letter, making 6 different variations. Next, we look at the numbers, "111." From the adjustments that we made to the code, we know that you can go through 0-9 (excluding the number we started at) variations. Finally, we need to test the original password (1 variation). In this case, since there are three different digits, there are 9 variations each. So, in total, there are 6 variations (the letters) + 9 variations (first 1) + 9 (variations (second 1) + 9 variations (third 1) + 1 variation (original password) which is a total of 34 variations tested for a match.

2. There a total of 2 duplicate passwords variations tested. This is because we know that our code will either check for uppercase or lowercase, or testing the numbers from 1 through 9. In this case, we are testing "secret118" and "secret111." When looking at these two passwords, you will notice that they are only off by one digits (8 and 1). From our code, it will check for "secret111" from "secret118" and "secret118" from "secret111." Looking at these two variations, there are a total of 2 duplicates as they check for each other. 

3. A way to change the implementation is to add an additional if statement to see if the password already exists. By introducing this additional if statement, we can avoid previous password variations that may have already been tested. Another option is to use a hashtable to see if the previous variation was already done, similarily to the if statement. By introducing either of these options, you can minimize repeated and redundant work.
